# Logs Management Documentation

This directory contains log files generated by the server application. Proper management and interpretation of these logs are crucial for monitoring the server's performance and troubleshooting issues.

## Log File Formats

The log files are generated in a structured format, typically in plain text or JSON. Each log entry includes a timestamp, log level (e.g., INFO, WARNING, ERROR), and a message describing the event.

## Common Log Levels

- **INFO**: General information about the application's operation.
- **WARNING**: Indicates a potential issue that should be monitored.
- **ERROR**: An error occurred that needs immediate attention.

## Managing Log Files

1. **Viewing Logs**: Use command-line tools like `cat`, `less`, or `tail` to view log files.
   - Example: `tail -f /path/to/logfile.log` to view logs in real-time.

2. **Rotating Logs**: Implement log rotation to manage disk space. This can be done using tools like `logrotate`.

3. **Archiving Logs**: Regularly archive old log files to prevent clutter and maintain performance.

## Troubleshooting Steps

- If you encounter issues, check the log files for ERROR entries.
- Look for patterns in WARNING entries that may indicate underlying problems.
- Ensure that the logging configuration is set correctly in the server configuration file.

For further assistance, refer to the main project documentation or contact the development team.

---

## Practical Logging Playbook

### Tail and filter quickly
- Follow in real time: `tail -F /var/log/myapp/app.log`
- Show last 200 lines with timestamps: `sed -n '1,200p' /var/log/myapp/app.log | nl`
- Filter by level or request id: `grep -E "ERROR|WARN|req=abc123" /var/log/myapp/app.log`

### Journald tips (systemd)
- Service logs live in the journal: `journalctl -u myapp -f`
- Since a time range: `journalctl -u myapp -S "2024-01-01 00:00" -U "2024-01-01 23:59"`
- Show only errors: `journalctl -p err..alert -u myapp --since today`

### Configure logrotate for an app
Create `/etc/logrotate.d/myapp`:
```
/var/log/myapp/*.log {
    daily
    rotate 14
    compress
    delaycompress
    missingok
    notifempty
    create 0640 app app
    sharedscripts
    postrotate
        systemctl kill -s HUP myapp || true
    endscript
}
```
- Dry run: `logrotate -d /etc/logrotate.conf`
- Force: `logrotate -f /etc/logrotate.conf`
- If the app cannot handle `HUP`, replace with `copytruncate` and remove `postrotate`.

### Ship logs to a central system (lightweight)
- rsyslog forwarder: add to `/etc/rsyslog.d/60-myapp.conf`:
```
if ($programname == 'myapp') then @@logs.company.internal:514
```
Then `systemctl restart rsyslog`.

### Real-life scenarios
- Disk almost full due to logs
  - Identify top consumers: `du -ah /var/log | sort -h | tail -n 20`
  - Add/adjust logrotate, verify `compress` enabled, clean old archives
  - Consider moving logs to a larger filesystem or S3/object storage

- No logs but service failing
  - Check journal for unit start errors: `journalctl -u myapp -b`
  - Increase verbosity: set `log_level=debug` in `src/configs/server.conf` (if respected by the app) and restart service

- Too many noisy logs
  - Lower `log_level` to `info` or `warn`, add sampling in the app, or filter at collector

---

## References
- `man journalctl`, `man logrotate`
- Linux logging stack patterns: journald ➝ rsyslog ➝ logrotate ➝ shipper (vector/fluent-bit)